<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Bashik</title>
    <link rel="stylesheet" href="bord.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Saira+Semi+Condensed&display=swap" rel="stylesheet">
</head>
<body>
    <header>
    
     <div class="container1">
        <div class = "okno">
            Bashik
        </div>
        
        <button class = "okno2 dropD">
                about me
        
            <div class="dropDcon">
                sagiev artur PSU IKNT ITH-1

            </div>
        </button>
            
        <button class="okno2 dropD">
            info
            <div class="dropDcon">
                Это сайт для подготовки к собеседованию на должность Linux разработчика.
            </div>
        </button>

            
        
           <a href="http://i91248we.beget.tech/" class="okno21 dropD">Trainer</a>

        
         
        </div>
    

    <div id = "about_me">
        <div id = "about">
             artur dead inside
        </div>
    </div>
</header>
<main>
    <div class = "container">
        <div class = "poick">
            CTRL + F search by page
        </div>        
    </div>
    <div class="container">
    <ul class = "for-ul " >
        <button class="for-button first">load average<div class="firstCon">LA (load average) — параметр, определяющий среднюю нагрузку на систему за период времени
            (1 мин, 5 минут, 15
            минут). Изменяется в количестве задач на одно ядро процессора. На нагрузку системы также влияет количество задач
            ввода-вывода и задержка сети. Также влияние на расчета LA оказывает: 1. Технология Hyper-Threading, которая
            делит одно физическое ядро на 2 логических, 2. Технология Turbo Bust, которая позволяет разгонять тактовую
            частоту процессора и работать на частоте выше заявленной, т.е. выше номинальной частоты (время на обработку
            одной задачи уменьшается)<br>Что будет если на сервере LA = 100?
            Ответ: Вероятно, что на сервере будет наблюдаться замедленная работа сервисов, но если параметр LA равен
            количеству ядер в системе или количеству потоков в системе, то данная нагрузка является нормальной.</div></button> <br>
    <button class="for-button first">Команда top. Что означает каждая запись в выводе<div class="firstCon">top-команда, которая позволяет 
        пользователям отслеживать процессы и использование системных ресурсов в Linux. она является интерактивной, и вы можете просматривать список процессов, 
        завершать процессы и сортировать.<br> 
        Нажать "1" чтобы в top посмотреть нагрузку на каждое ядро процессора, также отобразить все ядра. <br>
        Нажать "c", чтобы отобразить команды, которыми были запущены процессы. <br>
        top – название утилиты. <br>
        21:29:24 – текущее время системы.<br>
        up 14:18 – сколько система работает с момента последнего запуска.<br>
        1 user – количество пользователей авторизованных в системе.<br>
        load average: 0,78, 1,48, 1,10 – параметр средней нагрузки на систему за период времени 1 минута, 5 минут, 15 минут.<br>
        277 total – всего процессов в системе.
        3 running – количество процессов в работе. <br>
        274 sleeping – процессы в состоянии sleeping: ожидает какого-либо события или сигнала.<br>
        0 stopped – количество приостановленных процессов сигналом STOP или выполнением трассировки.<br>
        0 zombie – количество зомби-процессов, которые завершили своё выполнение, но присутствующие в системе, 
        чтобы дать родительскому процессу считать свой код завершения.<br>
        KiB Mem – количество оперативной памяти в кибибайтах (кратно 1024): <br> 
        7106404 total — всего доступно оперативной памяти в системе;<br> 
        306972 free — свободно оперативной памяти для использования; <br> 
        3127144 used — использовано оперативной памяти; <br> 
        3672288 buff/cache — буферизовано/закешировано оперативной памяти; <br>
        KiB Swap – количество swap-памяти в кибибайтах (кратно 1024), выделенные на диске: <br>
        8191996 total – всего выделено swap-памяти; <br>
        8191996 free – свободно swap-памяти; <br>
        0 used – использовано swap-памяти; <br>
        3270520 avail Mem – доступно для использования swap-памяти.</div></button> <br>
    <button class="for-button first">Где хранятся имена файлов и директорий <div class="firstCon">
    Они хранятся в каталогах.
    Каждый каталог представляет собой списек имен + номер инднексных дескрипторов. <br>
    Есть жесткие ссылки (имя + индекс дескриптора) указывают на файл, но не на каталог. <br>
    Есть символьные ссылки (файл внутри котрого имя другого файла) создать "-ln -s a/b/c"
    </div></button> <br>
    <button class="for-button first">Удаление файлов <div class="firstCon">
    rm имя файла <br> rm имя\ файла\ с\ пробелами <br>
    rm ./-rf или rm -- -rf (начинаются с тире) <br> 
    Можно удалить через уникальный номер: <br> ls -li <br>
    find .-inum [inode] -exec rm -i {} \; <br>
    Можно удалять файлы файловым менеджером mc
    </div></button> 
    <button class="for-button first">Описание дескриптора<div class="firstCon">
        stat имя_файла. <br>
        При вызове будут выводиться: <br>
        Имя файла. <br>
        Размер в байтах.<br>
        Количество выделенных блоков. Размер каждого блока в байтах. <br>
        Тип файла (файл, каталог, символическая ссылка).<br>
        Номер inode (уникальный код дескриптора).<br>
        Количество жестких ссылок.<br>
        Время последнего изменения содержимого файла. <br>
        Время последнего изменения содержимого или атрибута файла. <br>
        Время создания файла. <br>
        Чтобы узнать у символической ссылки надо stat -L ссылка.
    </div></button> <br>
    <button class="for-button first">PATH <div class="firstCon">
        Переменная окружения PATH - это системная переменная, которую ОС использует для того, 
        чтобы найти
        нужные испольняемые объекты. <br> 
        PATH - переменная окружения Unix, представляющая собой набор каталогов, 
        в которых расположены испольняемые
        файлы. <br>
        Принцип работы: <br>
        Сначала ОС ищет испольняемый файл в папке. Если находит, запускает на выполнение, если нет,
        проверяет каталоги, перечисленные в перенной PATH, в установленном там порядке. <br>
        В ОС Ubuntu значение переменной содердится в файле /etc/environment/ или /etc/profile/, 
        можно вручную прописать новый путь.  
        Чтобы добавить новый путь к переменной PATH надо прописать: <br>
        export PATH=$PATH:/ссылка_на_файл(путь).    <br>
        Чтобы проверить, содержиться ли новый путь в переменной PATH: <br>
        echo $PATH
    </div></button> <br>
    <button class="for-button first">Нагрузка на диски<div class="firstCon">
        Чтобы посмотреть нагрузку на диски придется установить допольнительные пакеты: <br>
         apt install sysstat. <br>
         Есть несколько способов:   <br>
         1)iostat -xtc <br>
         Выведет: <br>
         r/s - число операций чтения с диска в секунду <br>
         w/s - число операций записи на диск в секунду<br>
         rkB/s - число прочитанных килобайт за секунду<br>
         wkB/s - число записанных килобайт за секунду<br>
         2)pidsts -dl 5 <br>
         Из важного в выводе: <br>
         UID - идентификатор пользователя, от имени котрого работает процесс;<br>
         PID - идентификатор процесса;<br>
         kB_rd/s - скорость в килобайтах в секунду, с которой процесс читает диск;<br>
         kB_wr/s - скорость в килобайтах в секунду, с которой процесс записывается на диск;<br>
         3)top <br>
    </div></button> <br>
    <button class="for-button first">Что такое файл в понятиях Unix-like ОС<div class="firstCon">
        Файлы - объекты в которых хранится вся информация: наши данные, исполняемые файлы,
        файлы спец.назначения. <br>
        В Unix-Like ОС существует 7 типов файлов: <br>
        1) Обычный файл (Regular file) <br>
        2) Каталог (directory) - объект в файловой системе, позволяет сгруппировать файлы и 
        другие каталоги. <br>
        Корневой каталог - каталог, включающий в себя все прочие каталоги и файлы файловой 
        системы.(С:\, D:\) <br>
        Текущий каталог - каталог, с которым работает система <br>
        Родительский каталог - каталог, в котором находится текущий каталог(..) <br>
        3) Именованный канал (named pipe) - метод межпроцессного взаимодействия. Он позволяет 
        различным процессам
        обмениваться данными. <br>
        Создается mknod или mkfifo. <br>
        4) Символическая ссылка (soft link) - спец.файл в файловой системе, в котором 
        содержится путь к файлу, открываемому 
        при обращении к файлу. <br>
        Создается ln -s имя /ссылка/ <br>
        5) Специальный файл устройства (divice file) - содержит данные, необходимые 
        ОС для взаимодействия с 
        физ.устройствами, такими как диски, принтеры и тд. Эти файлы - указатели на 
        драйверы устройств 
        (работает с драйверами) <br>
        6) Сокет (socket) - программный интерфейс для обеспечения обмена данными между процессами. <br>
        7) Дверь (door) - механизм межпроцессного взаимодействия. <br> 
    </div></button> <br>
    <button class="for-button first">RAID<div class="firstCon">
        RAID - избыточный массив независимых дисков, технология виртуализации данных для 
        объединения нескольких
        физ. дисковых устройств в логический модуль для повышения отказоустойчивости и
         производительности.  <br>
        Виды RAID массивов (Дисков | допуск кол-во сбоев диск): <br>
        1) RAID 1 (4 | 3) <br>
        2) RAID 5 (>= 3 | 1) <br>
        3) RAID 6 (>= 4 | 2) <br>
        4) RAID 10 (>= 4 | половина всех дисков) <br>
        5) JBOD (>= 1 | 0) <br>
        6) SHR (1/2-3/>=4 | 0/1/1-2) <br>
        7) basic (1 | 0) <br>
        8) RAID F1 (>=3 | 1) <br>
    </div></button> <br>
    <button class="for-button first"> export <div class="firstCon">
        При объявлении через export переменная будет доступна в любых других процессах. <br>
        При обычном объявлении переменная будет доступна только в запущенном процессе. <br>
    </div></button> <br>
    <button class="for-button first">Остановка скрипта bash при возникновении ошибки<div class="firstCon">
        Остановить можно при помощи команды: set -e . 
    </div></button> <br>
    <button class="for-button first">set -euo pipefile<div class="firstCon">
        set - устанавливает опции <br>
        e - остановка скрипта при возникновении ошибки <br>
        u - остановка скрипта, если обноружится неопреденная переменная <br>
        o pipefile - в ходе пайплайна <br>
    </div></button> <br>
    <button class="for-button first">debug режим<div class="firstCon">
        В начале скрипта set -x <br>
    </div></button> <br>
    <button class="for-button first">$@ Аргументы<div class="firstCon">
        $@ - Список аргументов, которые входят в скрипт (при его вызове). <br>
        $# - Число аргуметов, которые поступили(в самом скрипте) <br>
        $* - Содержит все аргументы в виде одной строки(в самом скрипте) 
    </div></button> <br>
    <button class="for-button first">kill<div class="firstCon">
        kill - комнда для немедленного прекращения процесса. <br>
        kill -l - чтобы посмотреть полный список сигналов. <br> 
        SIGTERM (15) - запрашивает остановку процесса. Может быть проигнорирован.
        процессу дается время на выключение. <br>
        SIGKILL (9) - немедленно останавливает процесс. Не может быть проигнорирован. 
        Несохраненный процесс будет утерян. <br>
    </div></button> <br>
    <button class="for-button first">stderr<div class="firstCon">tekst</div></button> <br>
    <button class="for-button first">Пользователи на сервере<div class="firstCon">
        who - пользователи, которые находятся на сервере в настоящее время. <br>
        last - пользователи, которые в последнее время находились на серевере. <br> 
    </div></button> <br>
    <button class="for-button first">Отключение SHH аутентификации по паролю<div class="firstCon">
        1) Открыть файл etc/ssh/sshd_config; <br>
        2) Находим строку "#PasswordAuthentification yes"; <br>
        3) Убираем # , чтобы сделать его активным; <br>
        4) Меняем "yes" на "no". <br>
    </div></button> <br>
    <button class="for-button first">Смонтированные каталоги в файлы <div class="firstCon">
        Файлы etc/fstab - файл, хронящий статистическую, описательную информацию
        о файловых системах: <br>
        Мантируемое устройство <br>
        Точка мантирования <br>
        Тип файловой системы <br>
        Опции мантирования <br> 
    </div></button> <br>
    <button class="for-button first">cat a<div class="firstCon">
        fff
    </div></button> <br>
    <button class="for-button first">set -x <div class="firstCon">
        Чтобы пропустить ошибку, надо после кода с ошибкой написать "|| true " <br>
    </div></button> <br>
    <button class="for-button first">Системные вызовы<div class="firstCon">
        Системные вызовы - это механизмы взаимодействия пользовательских программ
        с ядром Linux. <br>
        Strace - инструмент для их отслеживания. <br>
        Примеры: mkdir, close, kill, link, exit, bind...<br>
    </div></button> <br>
    <button class="for-button first">Сигналы в Linux<div class="firstCon">
        Сигналы - уведомления процессора о каком-либо событии, основной способ взаимодействия 
        между процессами. <br>
        SIGTERM (15) - запрашивает остановку процесса. Может быть проигнорирован.
        процессу дается время на выключение. <br>
        SIGKILL (9) - немедленно останавливает процесс. Не может быть проигнорирован. 
        Несохраненный процесс будет утерян. <br>
    </div></button> <br>
    <button class="for-button first">inode<div class="firstCon">
        Inode - структура данных, которая хранит в себе метаинформацию
        (размер, расширение, владелец, расположение диска, время)
        о файлах,
        каталогах, кроме их данных и имени. <br>
        Например: ls -i myfile.txt 
    </div></button> <br>
    <button class="for-button first">hardlink и softlink<div class="firstCon">
        Hardlink - сслыка только на файл в файловой системе с тем же inode. <br>
        ln целевой_файл файл_ссылка<br>
        ln file1 hardlink1<br>
        ln file1 hardlink2<br>
        Два файла с разными именами будут иметь общий inode <br>
        Softlink - тип файлов, который содержит ссылку на другой файл или дирекорию в виде абсолютного или 
        относительно пути.  <br>
        ln -s путь_к_файлу файл_ссылка <br>
        chown -h your_user/:your_group ссылка <br>
    </div></button> <br>
    <button class="for-button first">Состояния процессоров<div class="firstCon">
R (running — запущенный). Процесс находится на обработке у процессора. <br>
R (runnable — готов к работе). Процесс готов к обработке и находится в очереди к процессору.
Running и runnable обозначаются одинаковой буквой R.<br>
D (uninterruptible sleep — в беспробудном сне). Когда процесс обращается к устройству, 
например к диску или сетевой карте, он переходит в это состояние.
А возвращается из него только после получения запрошенной информации.
Обычно в таком состоянии процесс находится не долго. 
В таком состоянии процесс перестает обрабатывать любые сигналы и, если что-то пойдет не так,
то завершить такой зависший процесс, не перезагружая сервер, не получится.<br>
I (Idle — бездействующий поток ядра). Состояние похоже на D, но такие процессы не нагружают процессор
и исключены из расчета средней нагрузки системы (load average).<br>
S (sleeping — спит). Процесс ожидает какие-то ресурсы, которые в данный момент недоступны.
При переходе в это состояние, процесс немедленно отказывается от доступа к процессору.
Когда ресурс, который ожидает процесс, становится доступным, 
процесс может снова перейти в состояние R (runnable). 
В спящем состоянии процесс продолжает обрабатывать сигналы.<br>
T (stopped by job control signal — остановленный специальным сигналом).процессы могут обрабатывать
сигналы и один из них может остановить процесс. Это состояние похоже на паузу,
то есть из этого состояния процесс может выйти и продолжить свою работу в состоянии R или S.<br>
t (stopped by debugger during trace — остановлен отладчиком во время трассировки). 
Состояние подобное T, но в этом случае остановка процесса произошла не по сигналу а во время отладки.
Z (zombie). Зомби процессы <br>
    </div></button> <br>
    <button class="for-button first">Зомби (zombie) и Процесс-сирота<div class="firstCon">
    Это дочерний процесс в системе, который завершил выполнение, но еще присутствует 
    в списке процессов. <br>
    Зомби процесс можно "убить" только завершив родительский процесс. 
    Посмотреть зомби процессы: ps ajx | gred defunct  3 колонка pid род<br>
    kill -9 Pid_процесса_родителя <br>
    Чтобы создать зомби процесс: <br>
    Процесс сирота - процесс, который остается неактивным или в рабочем состоянии
    даже после завершения родительского процесса. Он просто сохраняет свою запись 
    в список процессов. <br>
    Они бывают 2 типов: <br>
    1) Намеренно потерянный процесс. <br>
    2) Непредномеренно осиротевший процесс(при сбое родительского процесса) <br> 
    Вызов дочернего процесса fork <br>
    </div></button> <br>
    <button class="for-button first">Файловый дескриптор<div class="firstCon">
        Это натуральное число, закрепленное за определенным потоком ввода-вывода. <br> 
        Используется для получения доступа к потоку. <br>
        0 (STDIN) - ввод. <br>
        1 (STDOUT) - вывод. <br>
        2 (STDDER) - вывод ошибок. <br>
        Чтобы посмотреть дескриптор надо знать PID процесса и написать ls -lah/proc/pid/fd/total 0
    </div></button> <br>
    <button class="for-button first">free -m <div class="firstCon">
        Total. Эта цифра представляет всю существующую память. <br>
        Used вычисление общего значения оперативной памяти системы за вычетом выделенной
        свободной, разделяемой, буферной и кэш-памяти. <br>
        Free – свободная память в системе. <br>
        Shared – память, используемая (преимущественно) в tmpfs. <br>
        Buffer, и Cache идентифицируют память, используемую для нужд ядра
        /операционной системы. Буфер и кеш складываются вместе, а сумма 
        указывается в разделе «buff/cache». <br>
        Available – примерное количество оперативной памяти, доступное для
        запуска новых приложений без использования ими раздела подкачки.
        В отличие от поля free, это поле принимает в расчёт страницу cache и также то,
        что не вся рекуперируемая (пригодная для повторного использования) 
        память будет возвращена для рекуперации из-за того, что элементы используются
        в данный момент. <br>
        used = total - free - buff/cache

    </div></button> <br>
    <button class="for-button first">Запуск Linux<div class="firstCon">
        Включение компьютера кнопкой. <br>
        Загрузить BIOS / UEFI из NVRAM.<br>
        Собрать сведения об аппаратуре.<br>
        Выбрать устройства для запуска (диск, сеть).<br>
        Идентифицировать системный раздел EFI.<br>
        Загрузить BIOS / UEFI из NVRAM.<br>
        Определить какое ядро загрузить.<br>
        Загрузить ядро.<br>
        Создать структуры данных ядра.<br>
        Запустить init / systemd как PID 1.<br>
        Выполнить сценарии запуска.<br>
        Запустить систему.<br>
    </div></button> <br>
    <button class="for-button first">GitFlow<div class="firstCon">
        GitFlow — это определенная надстройка над моделью ветвления Git, 
        которая включает в себя использование фича веток и несколько основных веток. <br>
        У нас есть две основные ветки: master и develop. <br>
        В ветке master содержится ровно тот же код, что и в рабочей версии проекта.
        А вся работа делается в ветке develop. <br>
        
        Во время работы на основе develop создаются так называемые feature-ветки. 
        Их может быть неограниченное количество. <br>
        
        Далее, у нас есть ветка release, которая используется для подготовки к новому 
        релизу проекта. <br>
        
        Наконец, есть ветка hotfix, которая служит для срочного исправления багов, 
        найденных, например, на продакте. <br>
        Вот как в теории, происходит рабочий процесс в Gitflow: <br>
        1. Создается репозиторий <br>
        2. Репозиторий инициализируется <br>
        3. Начинается работа на ветке develop <br>
        4. Возникает необходимость опробовать новую штуку – создается feature-ветка
        и делаются коммиты <br>
        5. Закончив работу на feature-ветке, вы сливаете ее с develop <br>
        6. Если вы довольны текущей версией, но хотите продолжить работу, 
        создается ветка release, куда перемещается текущая версия. 
        Правка багов будет происходить на этой же ветке. <br>
        7. Когда с веткой release покончено, время слить ее в master и продолжить 
        работу с develop <br>
        Пример: <br>
        apt-get install git-flow <br>
        git flow init - инициализируем <br>
        git flow feature start MYFEATURE.
        Это действие создаёт новую ветку фичи,
        основанную на ветке "develop", и переключается на неё. <br>
        git flow feature finish MYFEATURE. Завершение фичи <br>
        git flow feature publish MYFEATURE. Публикации фичи <br>
        git flow feature pull origin MYFEATURE. Получение опубликованной фичи <br>
        git flow release start RELEASE [BASE]. Начало релиза <br>
        git flow release publish RELEASE. Публикация релиза <br>
        git flow release finish RELEASE. Финиш релиза <br>
        git flow hotfix start VERSION [BASENAME]. Начало исправлений <br>
        git flow hotfix finish VERSION. Завершение исправлений <br>
    </div></button> <br>
    <button class="for-button first">Git Merge и Git Rebase <div class="firstCon">
        Merge - Слияние принимает содержимое ветки источника и объединяет их с целевой 
        веткой. В этом процессе изменяется только целевая ветка.
        История исходных веток остается неизменной. <br>
        Слейте ветку master в ветку feature, используя команды checkout и merge. <br>
        $ git checkout feature <br>
        $ git merge master feature <br>
        Rebase сжимает все изменения в один «патч». 
        Затем он интегрирует патч в целевую ветку. <br>
        В отличие от слияния, перемещение перезаписывает историю, 
        потому что она передает 
        завершенную работу из одной ветки в другую. 
        В процессе устраняется нежелательная история. <br>
        Переместите ветку feature на главной ветке, используя следующие команды. <br>
        $ git checkout feature <br>
        $ git rebase master <br>
    </div></button> <br>
    <button class="for-button first"> develop в ветку master<div class="firstCon">
        git merge master
    </div></button> <br>
    <button class="for-button first">git commit --amend<div class="firstCon">
        git commit --amend позволяет добавить новые проиндексированные изменения 
        в последний коммит. С помощью коммита --amend можно добавлять изменения 
        в индекс Git или удалять таковые из него. 
    </div></button> <br>
    <button class="for-button first">Trunk Based Development<div class="firstCon">
        Характеризуется всего тремя типами веток и итеративным подходом к разработке фичи
    </div></button> <br>
    <button class="for-button first">Откат коммитов <div class="firstCon">
        git reset --hard "old-commit-id" <br>
        git push -f "remote-name" "branch-name" <br>
    </div></button> <br>
    <button class="for-button first">Docker<div class="firstCon">
        Это набор продуктов PaaS (Platform as a Service) - Платформа как услуга, 
        которые создают изолированные виртуализированные среды для создания, 
        развертывания и тестирования приложений. <br>
        Образ Docker (Docker Image) - это неизменяемый файл, содержащий исходный код, 
        библиотеки, зависимости, инструменты и другие файлы, 
        необходимые для запуска приложения.
        Образ - это шаблон, на основе которого создается контейнер, 
        существует отдельно и не может быть изменен. <br>
        Контейнер Docker (Docker Container) - это виртуализированная среда выполнения, 
        в которой пользователи могут изолировать приложения от хостовой системы. 
        Эти контейнеры представляют собой компактные портативные хосты, 
        в которых можно быстро и легко запустить приложение. <br>
        образы могут существовать без контейнеров, тогда как для существования 
        контейнеров необходимо запустить образ. Поэтому контейнеры зависят от 
        изображений и используют их для создания среды выполнения и запуска приложения. <br>
        docker images - посмотреть образы <br>
        docker ps - посмотреть контейнеры <br>
    </div></button> <br>
    <button class="for-button first">Инструкции Dockerfile <div class="firstCon">
        Инструкции Dockerfile: <br>
FROM — задаёт базовый (родительский) образ. <br>
LABEL — описывает метаданные. Например — сведения о том, 
кто создал и поддерживает образ. <br>
ENV — устанавливает постоянные переменные среды. <br>
RUN — выполняет команду и создаёт слой образа. Используется для установки 
в контейнер пакетов. <br>
COPY — копирует в контейнер файлы и папки которые лежат локально. <br>
ADD — копирует файлы и папки в контейнер, может распаковывать локальные 
.tar-файлы, а так же получать на вход URL и скачивать файл внутрь image. <br>
CMD — описывает команду с аргументами, которую нужно выполнить когда контейнер 
будет запущен. Аргументы могут быть переопределены при запуске контейнера. 
В файле может присутствовать лишь одна инструкция CMD. <br>
WORKDIR — задаёт рабочую директорию для следующей инструкции. <br>
ARG — задаёт переменные для передачи Docker во время сборки образа. <br>
ENTRYPOINT — предоставляет команду с аргументами для вызова во время выполнения 
контейнера. Аргументы не переопределяются. <br>
EXPOSE — указывает на необходимость открыть порт. Также можно открыть socket, 
но это тема для отдельной заметки. <br>
VOLUME — создаёт точку монтирования для работы с постоянным хранилищем. <br>
    </div></button> <br>
    <button class="for-button first">ENTRYPOINT и CMD <div class="firstCon">
        Основное отличие между ENTRYPOINT и CMD заключается в том, что 
        ENTRYPOINT задает команду, которая не будет переопределена при 
        запуске контейнера с другой командой, в то время как CMD позволяет 
        перезаписать заданную команду. <br>
    </div></button> <br>
    <button class="for-button first">ADD и COPY <div class="firstCon">
        ADD, и COPY предназначены для добавления каталогов и файлов в ваш образ Docker. <br>
        ADD в отличии от COPY может Загрузите файл по URL-адресу и Извлечение локально сохраненных файлов tar.
    </div></button> <br>
    <button class="for-button first">Драйвера Docker <div class="firstCon">
        Для того, чтобы работать с сетью Docker необходимы драйверы. 
        Имеется несколько драйверов по умолчанию, которые обеспечивают 
        основной функционал по работе с сетью: <br>

        none: отключение всех сетевых ресурсов. <br>

        bridge: сетевой драйвер по умолчанию. По сути, это мост между контейнером и 
        хостовой машиной. Мостовые сети обычно используются, когда приложения 
        выполняются в автономных контейнерах, которые должны взаимодействовать 
        друг с другом. <br>

        host: для автономных контейнеров устраняется сетевая изолированность между 
        контейнером и хостом Docker и напрямую используются сетевые ресурсы хоста. <br>

        overlay: наложенные сети соединяют несколько демонов Docker. <br>

        macvlan: сети Macvlan позволяют присваивать контейнеру MAC-адрес, 
        благодаря чему он выглядит как физическое устройство в сети. <br>
    </div></button> <br>
    <button class="for-button first">Эфемерные контейнеры <div class="firstCon">
        Эфемерные контейнеры — это временные контейнеры, которые создаются и 
        уничтожаются во время выполнения задачи. Их основная особенность состоит 
        в том, что они не сохраняют свое состояние после завершения работы. 
        Такой подход позволяет уменьшить расход ресурсов, улучшить безопасность 
        и ускорить выполнение задач. 
    </div></button> <br>
    </ul>
    </div>
</main>
    <script src="red.js"></script>
</body>
</html>


